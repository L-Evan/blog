---

title: "浏览器原理" # 标题
date: 2021-10-02T01:04:30+08:00    # 创建时间
lastmod: 2021-10-02T01:04:30+08:00 # 最后修改时间
tags: ['前端']
categories: ['前端']  # 分类 

---

# 浏览器是怎么运行的

## 知识点汇集

1. 进程分布

![image-20210222153316902](https://pig-blog-1252563418.cos.ap-chengdu.myqcloud.com/img/blog/image-20210222153316902.png)

2. 渲染进程（浏览器内核进程）

   ![img](https://pig-blog-1252563418.cos.ap-chengdu.myqcloud.com/img/blog/1460000012925880)

3. 一个标签一个渲染进程（JS引擎线程和GUI渲染线程为主），然后只有一个**主控进程**

4. 除了js外的其他内核线程（渲染进程）特点

   - GUI渲染进程

     - 可能需要**浏览器进程**获取资源和需要**GPU进程**来帮助渲染

     - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

       > 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
       >
       > 目的在于，防止js dom操作导致和渲染不一致
       >
       > 所以，要尽量**避免JS执行时间过长**，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

   - 事件触发线程：不属于js线程所以，JS引擎空闲时才会去执行

   - 定时器线程：并不是由JavaScript引擎计数的，保证准确性（js堵塞）

     - 注意，W3C在HTML标准中规定，规定要求**setTimeout中低于4ms的时间间隔算为4ms**。
     - 因为是单线程的  不推荐用setInterval   代码运行时间>setTimeout 有隐患，瞬间执行多代码

   - 异步http请求线程：同样将**产生状态变更事件**，将这个回调再放入事件队列（事件线程）中。

5. 进程间的通讯通过 **进程间通信（IPC）**

6. 前面说到，Browser进程（控制进程）关系

   ![image-20210222160712756](https://pig-blog-1252563418.cos.ap-chengdu.myqcloud.com/img/blog/image-20210222160712756.png)



## 流程（参考公众号文章）

1. 输入url，浏览器进程： UI线程分析后，交给网络线程（DNS解析，TLS）

2. 网络线程会解析信息是否正确，不一致MIME 类型嗅探来猜测该数据的类型等，然后发给UI线程

3. UI接受到也会进程检查如**C**ross **O**rigin **R**ead **B**locking（**CORB**）等

4. 并且IPC沟通交给**渲染进程**去处理（渲染进程，在交给网络线程的时候已经预处理开启了）

5. 渲染进程处理

   Dom树渲染，3D场景渲染（分层等）

6. 对于事件监听

   浏览器进程获取数据后，交给渲染层

 ## 特殊点备注（以下转载复制）

### 为了解决单线程问题,H5引入了webworker

- 创建Worker时，JS引擎向浏览器申请开一个子线程 (子线程是浏览器开的，在标签进程，完全受主线程控制，而且不能操作DOM，不和其他标签沟通）
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

- **JS引擎是单线程的**，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂(Worker线程)，专门用来解决那些大量计算问题。

### 简单梳理下浏览器渲染流程

本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）

为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）

- 浏览器输入url，浏览器主进程接管，开一个下载线程，
  然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
  随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始

浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

1. 解析html建立dom树

2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）

3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

   ​	（Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。）

4. 绘制render树（paint），绘制页面像素信息（渲染对象是一个包含有颜色和大小等属性的矩形）

   - 浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）

5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

所有详细步骤都已经略去，渲染完毕后就是`load`事件了，之后就是自己的JS逻辑处理了

既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。

这里重绘参考来源中的一张图：（参考来源第一篇）

![img](https://pig-blog-1252563418.cos.ap-chengdu.myqcloud.com/img/blog/1460000012934765)

-------------



[公众号文章]:https://mp.weixin.qq.com/s/11MRrxmiyZybTUbjRDRubQ
[CSDN]:https://www.cnblogs.com/cangqinglang/p/8963557.html


