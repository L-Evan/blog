---
title: "背包问题思考" # 标题
date: 2021-10-05T19:37:46+08:00    # 创建时间
lastmod: 2021-10-05T19:37:46+08:00 # 最后修改时间
tags: ['算法','动态规划']
categories: ['算法']  # 分类
---

# **背包问题**

**最基础的简单01背包问题，在给定的背包大小M，存放物品价值达到最大V，每件物品大小为mi，价值为vi**

## **二维背包**

**每个物品有对应的编号，大小和价值，：n  m  v**

**所以我们可以采用DP状态容量的方式，也就是放第n个物品时，无论放不放，算出背包剩余的各个容量的价值的最优（局部最优）**

```
// 开始填表
for (int m = 1; m <= i; m++){
    for (int n = 1; n <= j; n++){
        if (n < ws[m]){
            // 装不进去
            results[m][n] = results[m-1][n];
        } else {
            // 容量足够
            if (results[m-1][n] > results[m-1][n-ws[m]] + vs[m]){
                // 不装该珠宝，最优价值更大
                results[m][n] = results[m-1][n];
            } else {
                //DP核心
                results[m][n] = results[m-1][n-ws[m]] + vs[m];
            }
        }
    }
}
```

## **一维背包**

### ****二维背包****

**二维背包内存为n^2   时间也为n^2  ，在dp容量    **`for (int n = 1; n <= j; n++){   results[m][n] = results[m-1][n-ws[m]] + vs[m]}`

****压缩的条件****

**通过观察dp的二维图，我们不难发现，每次dp都是往后取状态的，我们可以利用此特点。**

### ****一维背包****

****已有前提条件****

`results[m-1][n-ws[m]] 总是在 results[m][n] 的左上方`

1. `n-ws[m]`**往******左边是从剩下容量里放东西******（m>=0）**
2. `m-1`**采取二维的方式存储，因为要******拿到前一个状态的老状态，也就是上面******，需要记录他。**

****假设使用一维****

**这时候，我们可以根据前提条件，假设将状态******只存一维的方式****

> ** 我们可以来设想，一维的方式会有什么区别？**

**二维就是获取老状态，而一维导致的问题，也就是最新状态覆盖了老状态******导致状态丢失******，也就是******状态覆盖问题****

****解决方法****

**	****如果当n=2的时候，原来** `dp[1][0-m]`**已经更新在一维数组里面，也就是现在** `dp[0-m]`**好了，我们从满容量开始dp。**

**	****我们现在采取，从最大值******m 开始更新新状态******，会发现每次获取状态都是******往小于当前值去取******（也就是前提条件1），而又因为是******从最大容量开始往下更新新状态******，所以更新顺序是先**`dp[100](要0-99) dp[99](要0-98) dp[98](要0-97)`**  ******往左取的都是没更新的老状态******（也就是前提条件2）.**

![1](https://pig-blog-1252563418.cos.ap-chengdu.myqcloud.com/img/blog/DS9JtTpilL5faU1.png)

* **注意：如果是从小到大的话可以解决无限硬币问题，不像完全背包，而是循环覆盖，每次都要最新的状态，******每个最新状态都想得到之前的最新状态******，leetcode322**

## **完全背包问题**

**每种物品都有无限件，可用时间复杂度变成** `(n*m)*n`

**想法1：在01背包基础上，嵌套第三循环选择数量**

* **i = id  j = 数量  k= 容量（无法压缩一维数组）**
* **i=id j=容量 k=数量**

**想法2：转化为01背包，为可以选择的数量转化为一个 **`v*n  w*n`** 的物品**

* **可以，仍然保留着容量价值组合的关系**
* **带来问题，时间复杂度并并没降低（数量组合比较有多余的）**

****想法2二进制优化****

* **背包的dp本质就是容量和价值的一个组合，采用******二进制拆分数量******可以利用这种组合****也就是我们，可以吧A数量设置为  1   10   100  1000   10000  100000   1000000，并将视为******数量1的独立物品****

**当对背包dp的时候，如果******A物品要的数量是10010****** ， 那么就转变成A物品数量拆分过程中的重新组合（10000 和10  2个拆分的A）**

**也就真正的完成了完全背包向01背包的转变**

### **分组背包**

**n组物品，每组只能选一个（相当每个i多了选择，那就多套一层循环hhh）**

* **直接对分组进行多筛选**
* **i  组号  j  容量   k  组内编号**

```
for(int i = 1; i <= n; i++)
        for(int j = m; j >= 0; j--)
            for(int k = 0; k < s[i]; k++) //枚举组内元素
                if(v[i][k] <= j)
                    f[j] = max(f[j], f[j-v[i][k]] + w[i][k]); 
```

## **总结**

### **背包问题**

****01背包******作为最基础的背包，核心是以局部的******当前条件的最优组合******，不同于贪心的是，贪心******所用条件最优组合****

> **对01背包的优化，核心在于压缩背包和完全背包问题**

****压缩背包******问题是巧妙的运用******往回找******的特性，达到******二维压缩到一维******的转换（与之类似，运用往前找的是零钱问题）**

****完全背包******问题主要在于二进制优化和背包转换问题，而背包转换便是核心**

* **背包转换问题，将******物品的数量叠加（有限制的叠加）转变成物品种类的增加******问题，再用二进制优化解决物品种类增加导致的******物品重复问题****

  * **还有就是******物品价值问题******（可选优化，因为无限物品或者叠加，可能出现物品价值低（******贪心******，同大小不同价值之类）的物品）**
* **二进制优化则是运用了将******十进度数的相加组合转换二进制的相加组合******，然后再由二进制的相加组合**`2^n`**  n个数的相加组合，也就是实际上解决的是******数值的组合******问题，不仅运用在01背包上，包括快速幂的场景也类似。**

> ** 简单变种问题**

****组合背包******问题则类似完全背包（未优化的），简单的一种难度提升。**

**二维费率（leecode 474）感觉更容易理解，将******核心条件的组合问题******2^n 转化成******约束条件组合问题******，大大降低复杂度（需要看n规模），dp的值也由n向m转化（感觉有点hash的思想）**

**硬币问题（322 ），看起来像是完全背包，可是如果只采用压缩背包的逆序，其实更好解决，也就是压缩背包的核心思想的运用**

### **动态规划问题**

**背包问题只是对动态规划的一种经典应用，核心都在于利用过去的最优，转变成现在的最优。**

* **还有一些如《打家劫舍》 石头抵消问题（1049 ）。。。。。**
